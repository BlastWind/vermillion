

grammar
=======
S -> if E then S else S
S -> print E
E -> num = num

parse table (for above grammar)
===============================
S -> if    -> if E then S else S
  -> print -> print E

E -> num -> num = num

input
=====
[if, num, =, num, then, print, num, =, num, else, print, num, =, num]

trace
=====

parse tbl
      S	
      [if, num, =, num, then, print, num, =, num, else, print, num, =, num]

(* the three parseLoop arguments here are the grammar symbol stack, input, and
   semantic stack *)
parseLoop [NT S]
	  [if, num, =, num, then, print, num, =, num, else, print, num, =, num]
	  []

NT case
-------
parseTableLookup (NT S) (T if) = [T if, NT E, T then, NT S, T else, NT S]
sep = Sep S 6    (* length of production's right side = 6 *)

parseLoop [T if, NT E, T then, NT S, T else, NT S, Sep S 6]
          [if, num, =, num, then, print, num, =, num, else, print, num, =, num]
	  []

T case
------
cmpSym (T if) (T if) = true

parseLoop [NT E, T then, NT S, T else, NT S, Sep S 6]
	  [num, =, num, then, print, num, =, num, else, print, num, =, num]
	  [Leaf if] 	     

NT case
-------
parseTableLookup (NT E) (T num) = [T num, T =, T num]
sep = Sep E 3    (* length of production's right side = 3 *)

parseLoop [T num, T =, T num, Sep E 3, T then, NT S, T else, NT S, Sep S 6]
	  [num, =, num, then, print, num, =, num, else, print, num, =, num]
	  [Leaf if]

T case
------
cmpSym (T num) (T num) = true

parseLoop [T =, T num, Sep E 3, T then, NT S, T else, NT S, Sep S 6]
	  [=, num, then, print, num, =, num, else, print, num, =, num]
	  [Leaf num, Leaf if]	

T case
------
cmpSym (T =) (T =) = true

parseLoop [T num, Sep E 3, T then, NT S, T else, NT S, Sep S 6]
	  [num, then, print, num, =, num, else, print, num, =, num]
          [Leaf =, Leaf num, Leaf if]

T case
------
cmpSym (T num) (T num) = true

parseLoop [Sep E 3, T then, NT S, T else, NT S, Sep S 6]
	  [then, print, num, =, num, else, print, num, =, num]
	  [Leaf num, Leaf =, Leaf num, Leaf if]

Sep case
--------
subtree = Node E [Leaf num, Leaf =, Leaf num]

parseLoop [T then, NT S, T else, NT S, Sep S 6]
	  [then, print, num, =, num, else, print, num, =, num]
	  [Node E [Leaf num, Leaf =, Leaf num], Leaf if]

T case
------
cmpSym (T then) (T then) = true

parseLoop [NT S, T else, NT S, Sep S 6]
	  [print, num, =, num, else, print, num, =, num]
	  [Leaf then, Node E [Leaf num, Leaf =, Leaf num], Leaf if]

NT case
-------
parseTableLookup (NT S) (T print) = [T print, NT E]
sep = Sep S 2

parseLoop [T print, NT E, Sep S 2, T else, NT S, Sep S 6]
	  [print, num, =, num, else, print, num, =, num]
	  [Leaf then, Node E [Leaf num, Leaf =, Leaf num], Leaf if]

T case
------
cmpSym (T print) (T print) = true

parseLoop [NT E, Sep S 2, T else, NT S, Sep S 6]
	  [num, =, num, else, print, num, =, num]
	  [Leaf print, Leaf then, Node E [Leaf num, Leaf =, Leaf num], Leaf if]

NT case
-------
parseTableLookup (NT E) (T num) = [T num, T =, T num]
sep = Sep E 3

parseLoop [T num, T =, T num, Sep E 3, Sep S 2, T else, NT S, Sep S 6]
	  [num, =, num, else, print, num, =, num]
	  [Leaf print, Leaf then, Node E [Leaf num, Leaf =, Leaf num], Leaf if]

T case
------
cmpSym (T num) (T num) = true

parseLoop [T =, T num, Sep E 3, Sep S 2, T else, NT S, Sep S 6]
	  [=, num, else, print, num, =, num]
	  [Leaf num,
	   Leaf print,
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]
	  
T case
------
cmpSym (T =) (T =) = true

parseLoop [T num, Sep E 3, Sep S 2, T else, NT S, Sep S 6]
	  [num, else, print, num, =, num]
	  [Leaf =,
	   Leaf num,
	   Leaf print,
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]
	   
T case
------
cmpSym (T num) (T num) = true

parseLoop [Sep E 3, Sep S 2, T else, NT S, Sep S 6]
	  [else, print, num, =, num]
	  [Leaf num,
	   Leaf =,
	   Leaf num,
	   Leaf print,
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

Sep case
--------
subtree = Node E [Leaf num, Leaf =, Leaf num]

parseLoop [Sep S 2, T else, NT S, Sep S 6]
	  [else, print, num, =, num]
	  [Node E [Leaf num, Leaf =, Leaf num],
	   Leaf print,
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

Sep case
--------
subtree = Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]]

parseLoop [T else, NT S, Sep S 6]
	  [else, print, num, =, num]
	  [Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

T case
------
cmpSym (T else) (T else) = true

parseLoop [NT S, Sep S 6]
	  [print, num, =, num]
	  [Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

NT case
-------
parseTableLookup (NT S) (T print) = [T print, NT E]
sep = Sep S 2

parseLoop [T print, NT E, Sep S 2, Sep S 6]
	  [print, num, =, num]
	  [Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

T case
------
cmpSym (T print) (T print) = true

parseLoop [NT E, Sep S 2, Sep S 6]
	  [num, =, num]
	  [Leaf print,
	   Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

NT case
-------
parseTableLookup (NT E) (T num) = [T num, T =, T num]
sep = Sep E 3

parseLoop [T num, T =, T num, Sep E 3, Sep S 2, Sep S 6]
	  [num, =, num]
	  [Leaf print,
	   Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

T case
------
cmpSym (T num) (T num) = true

parseLoop [T =, T num, Sep E 3, Sep S 2, Sep S 6]
	  [=, num]
	  [Leaf num,
	   Leaf print,
	   Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

T case
------
cmpSym (T =) (T =) = true

parseLoop [T num, Sep E 3, Sep S 2, Sep S 6]
	  [num]
	  [Leaf =,
	   Leaf num,
	   Leaf print,
	   Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

T case
------
cmpSym (T num) (T num) = true

parseLoop [Sep E 3, Sep S 2, Sep S 6]
	  []
	  [Leaf num,
	   Leaf =,
	   Leaf num,
	   Leaf print,
	   Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

Sep case
--------
subtree = Node E [Leaf num, Leaf =, Leaf num]

parseLoop [Sep S 2, Sep S 6]
	  []
	  [Node E [Leaf num, Leaf =, Leaf num],
	   Leaf print,
	   Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

Sep case
--------
subtree = Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]]

parseLoop [Sep S 6]
	  []
	  [Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf else,
	   Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	   Leaf then,
	   Node E [Leaf num, Leaf =, Leaf num],
	   Leaf if]

Sep case
--------
subtree = Node S [Leaf if,
                  Node E [Leaf num, Leaf =, Leaf num],
		  Leaf then,
		  Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
		  Leaf else,
		  Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]]]

parseLoop []
	  []
	  [Node S [Leaf if,
                  Node E [Leaf num, Leaf =, Leaf num],
		  Leaf then,
		  Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
		  Leaf else,
		  Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]]]]


stack of grammar symbols is empty -- return the head of the semantic stack:

Node S [Leaf if,
        Node E [Leaf num, Leaf =, Leaf num],	
	Leaf then,
	Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]],
	Leaf else,
	Node S [Leaf print, Node E [Leaf num, Leaf =, Leaf num]]]


Observations
============
- It's always the case that the remaining grammar symbols on the stack
  (excluding the Sep elements) derive the remaining input

- The grammar symbols on the stack up to the first Sep always derive a prefix of
  the input
